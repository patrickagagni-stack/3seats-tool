<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Tripleseat Export Tool</title>
  <style>
    :root { --bg:#0b1020; --fg:#e9eef7; --muted:#98a2b3; --brand:#4f46e5; --card:#141a2f; --border:#24304d; }
    html,body { margin:0; padding:0; background:var(--bg); color:var(--fg); font:14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"; }
    .wrap { max-width:1100px; margin:24px auto; padding:0 16px; }
    h1 { margin:0 0 16px; font-size:22px; font-weight:700; letter-spacing:.2px; }
    .card { background:var(--card); border:1px solid var(--border); border-radius:14px; padding:16px; }
    .row { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .btn { appearance:none; border:1px solid var(--border); background:#16203b; color:var(--fg); padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:600; letter-spacing:.3px; transition:transform .04s ease; }
    .btn:hover { transform:translateY(-1px); }
    .btn.primary { background:var(--brand); border-color:#4338ca; }
    .btn:disabled { opacity:.5; cursor:not-allowed; }
    .muted { color:var(--muted); }
    .note { margin-top:8px; font-size:13px; color:var(--muted); }
    .spacer { flex:1; }
    table { width:100%; border-collapse:collapse; background:#0f162b; border-radius:12px; overflow:hidden; }
    thead th { text-align:left; font-size:13px; color:#cbd5e1; padding:10px 12px; border-bottom:1px solid #1e293b; background:#101a33; }
    tbody td { padding:10px 12px; border-bottom:1px solid #1e293b; }
    .footer { margin-top:28px; font-size:12px; color:#94a3b8; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Tripleseat Export â†’ Google Sheets</h1>
    <div class="card">
      <div class="row">
        <button id="generateBtn" class="btn">Generate (your normal step)</button>
        <div class="spacer"></div>
        <input id="fileName" placeholder="File name (default: master_output)" class="btn" style="background:#0f172a;border:1px solid var(--border);width:260px" />
        <input id="sheetName" placeholder="Sheet tab (default: Events)" class="btn" style="background:#0f172a;border:1px solid var(--border);width:220px" />
        <button id="exportToSheetsBtn" class="btn primary" type="button">Export to Google Sheet</button>
      </div>
      <div class="note">Use your existing workflow to <strong>Generate</strong> data first so a results table is visible below. Then click <strong>Export to Google Sheet</strong>.</div>
    </div>

    <div class="card" style="margin-top:16px">
      <div class="muted" style="margin-bottom:8px">Results preview (example table placeholder). Replace this with your real results table.</div>
      <table id="previewTable">
        <thead><tr>
          <th>Event Name</th><th>Owner</th><th>Room</th><th>Status</th><th>Date</th>
        </tr></thead>
        <tbody>
          <tr><td>Test Event A</td><td>Alice</td><td>Ballroom, Patio</td><td>Prospect</td><td>2025-10-01</td></tr>
          <tr><td>Test Event B</td><td>Bob</td><td>Garden</td><td>CustomStatus</td><td>2025-10-02</td></tr>
        </tbody>
      </table>
    </div>

    <div class="footer">Client ID is embedded; no secrets are stored. Each user grants access with their own Google account.</div>
  </div>

  <!-- Google APIs (client only) and Google Identity Services -->
  <script async defer src="https://apis.google.com/js/api.js"></script>
  <script async defer src="https://accounts.google.com/gsi/client"></script>

  <script>
  (function(){
    const CLIENT_ID   = "7010858919-jq4n8blq1b73o26pq3h4n0uk46roqfag.apps.googleusercontent.com";
    const TEMPLATE_ID = "1ft0PuCB3EneQ8vW9lFv78c1KBC1giUOGTAmLsa8bETE";
    const SCOPES      = 'https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/spreadsheets';

    function $(id) { return document.getElementById(id); }
    function val(id, fallback) { const v = $(id)?.value?.trim(); return v ? v : fallback; }

    function scrapeTable() {
      const tables = Array.from(document.querySelectorAll('table'));
      if (!tables.length) return null;
      function extract(t){
        const thead = t.querySelector('thead');
        const tbody = t.querySelector('tbody');
        let headers = [];
        let dataRows = [];
        if (thead) headers = Array.from(thead.querySelectorAll('th,td')).map(th => th.textContent.trim());
        const rowEls = tbody ? Array.from(tbody.querySelectorAll('tr')) : Array.from(t.querySelectorAll('tr'));
        if (!headers.length && rowEls.length) {
          const first = rowEls.shift();
          const firstCells = Array.from(first.querySelectorAll('th,td'));
          headers = firstCells.map(td => td.textContent.trim());
        }
        for (const tr of rowEls) {
          const cells = Array.from(tr.querySelectorAll('td,th')).map(td => td.textContent.trim());
          if (cells.length && cells.some(v => v!=='') ) dataRows.push(cells);
        }
        const cols = Math.max(headers.length, ...dataRows.map(r=>r.length));
        return { headers, dataRows, rows: dataRows.length, cols };
      }
      let best = null, score = -1;
      for (const t of tables) {
        const d = extract(t);
        const s = (d.rows||0) * (d.cols||0);
        if (d.headers && d.headers.length && d.rows && s > score) { best = d; score = s; }
      }
      if (!best) return null;
      const seen = {}, normHeaders = best.headers.map(h => { let k=(h||'').trim()||'Column', b=k, i=1; while (seen[k]) { i++; k=`${b}_${i}`; } seen[k]=true; return k; });
      const outRows = best.dataRows.map(cells => { const o={}; for (let i=0;i<normHeaders.length;i++) o[normHeaders[i]] = (cells[i] ?? '').trim(); return o; });
      return { headersOut: normHeaders, outRows };
    }

    function splitRooms(val) {
      if (!val) return [];
      const seps = [',','/',';','|',':'];
      let s = String(val);
      for (const sp of seps) s = s.split(sp).join(',');
      return s.split(',').map(v=>v.trim()).filter(Boolean);
    }

    function computeLists(headersOut, outRows) {
      const owners = new Set(), rooms = new Set(), statuses = new Set();
      const idxOf = (needle) => { const lc=headersOut.map(h=>(h||'').toLowerCase()); const e=lc.indexOf(needle.toLowerCase()); if (e!==-1) return e; for (let i=0;i<lc.length;i++) if (lc[i].includes(needle.toLowerCase())) return i; return -1; };
      const iOwner = idxOf('owner'), iRoom = idxOf('room'), iStat = idxOf('status');
      for (const r of outRows) {
        const vals = headersOut.map(h => r[h]);
        if (iOwner !== -1 && vals[iOwner]) owners.add(String(vals[iOwner]).trim());
        if (iRoom  !== -1 && vals[iRoom])  splitRooms(vals[iRoom]).forEach(x => rooms.add(x));
        if (iStat  !== -1 && vals[iStat])  statuses.add(String(vals[iStat]).trim());
      }
      const CANON = new Set(['Prospect','Tentative','Definite','Closed','Lost']);
      const unmatchedStatuses = Array.from(statuses).filter(s => !CANON.has(s));
      return {
        rooms: Array.from(rooms),
        owners: Array.from(owners),
        statuses: unmatchedStatuses,
        nonMatched: []
      };
    }

    async function gapiLoad(){
      if (typeof gapi === 'undefined') throw new Error('Google API failed to load. Use your GitHub Pages URL or http://localhost.');
      return new Promise((resolve,reject)=>{
        gapi.load('client', async ()=>{
          try { await gapi.client.init({}); resolve(); }
          catch(e){ reject(e); }
        });
      });
    }
    let tokenClient = null;
    function ensureTokenClient(){
      if (!window.google || !google.accounts || !google.accounts.oauth2) throw new Error('Google Identity Services failed to load.');
      if (!tokenClient) tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: CLIENT_ID,
        scope: SCOPES,
        callback: ()=>{}
      });
      return tokenClient;
    }
    async function acquireAccessToken(forceConsent=false){
      return new Promise((resolve,reject)=>{
        try {
          const tc = ensureTokenClient();
          tc.callback = (resp)=>{
            if (resp && resp.access_token) resolve(resp.access_token);
            else reject(new Error(resp && resp.error ? resp.error : 'Failed to obtain access token'));
          };
          tc.requestAccessToken({ prompt: forceConsent ? 'consent' : '' });
        } catch(e) { reject(e); }
      });
    }

    async function copyTemplate(name){
      const res = await gapi.client.request({
        path:`/drive/v3/files/${encodeURIComponent(TEMPLATE_ID)}/copy`,
        method:'POST',
        params:{fields:'id'},
        body:{ name }
      });
      return res.result.id;
    }
    async function writeValues(id, sheet, values){
      await gapi.client.request({
        path:`/v4/spreadsheets/${encodeURIComponent(id)}/values/${encodeURIComponent(sheet)}!A1`,
        method:'PUT',
        params:{ valueInputOption:'RAW' },
        body:{ range:`${sheet}!A1`, majorDimension:'ROWS', values }
      });
    }
    async function clearOrAddSheet(id, title){
      try {
        await gapi.client.request({
          path:`/v4/spreadsheets/${encodeURIComponent(id)}/values/${encodeURIComponent(title)}!A1:ZZ99999:clear`,
          method:'POST'
        });
      } catch(e) {
        await gapi.client.request({
          path:`/v4/spreadsheets/${encodeURIComponent(id)}:batchUpdate`,
          method:'POST',
          body:{ requests:[{ addSheet: { properties: { title } } }] }
        });
      }
    }

    async function exportToSheets(){
      const snap = scrapeTable();
      if (!snap || !snap.headersOut.length || !snap.outRows.length) {
        alert('No table detected. Run your normal Generate so the results table is visible.');
        return;
      }
      const eventsGrid = [ snap.headersOut, ...snap.outRows.map(r => snap.headersOut.map(h => r[h] ?? '')) ];

      const lists = computeLists(snap.headersOut, snap.outRows);
      const listsHeaders = ['room','room in TS','', 'owners','owners in TS','', 'status','', 'unmatched_rooms','unmatched_owners','unmatched_status','appended_headers'];
      const maxLen = Math.max(lists.rooms.length, lists.owners.length, lists.statuses.length, lists.nonMatched.length, 1);
      const listsGrid = [listsHeaders];
      for (let i=0;i<maxLen;i++) {
        const A=lists.rooms[i]||'', D=lists.owners[i]||'', G=lists.statuses[i]||'', L=lists.nonMatched[i]||''; const row=i+2;
        const I=`=IF(A${row}="","",IF(COUNTIF($B:$B,A${row})>0,"",A${row}))`;
        const J=`=IF(D${row}="","",IF(COUNTIF($E:$E,D${row})>0,"",D${row}))`;
        const K=`=IF(G${row}="","",IF(ISNUMBER(MATCH(G${row},{"Prospect","Tentative","Definite","Closed","Lost"},0)),"",G${row}))`;
        listsGrid.push([A,'','',D,'','',G,'',I,J,K,L]);
      }

      await gapiLoad();
      const tok = await acquireAccessToken();
      gapi.client.setToken({ access_token: tok });

      const sheetName = val('sheetName','Events');
      const fileName  = (val('fileName','master_output').replace(/\s+/g,'_')) + ' (Google Sheet)';
      const id = await copyTemplate(fileName);

      await clearOrAddSheet(id, sheetName);
      await writeValues(id, sheetName, eventsGrid);
      await clearOrAddSheet(id, 'Lists');
      await writeValues(id, 'Lists', listsGrid);

      window.open(`https://docs.google.com/spreadsheets/d/${id}/edit`, '_blank');
    }

    document.addEventListener('DOMContentLoaded', () => {
      const btn = $('exportToSheetsBtn');
      if (btn) btn.addEventListener('click', exportToSheets);
    });
  })();
  </script>
</body>
</html>
