<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3seats — Export with Lists Formulas Preserved</title>
  <style>
    :root { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    body { margin:0; padding:28px; background:#fafafa; color:#111; }
    .wrap { max-width: 900px; margin: 0 auto; }
    h1 { margin:0 0 8px; font-size:22px; }
    .card { background:#fff; border:1px solid #e5e7eb; border-radius:12px; padding:16px 18px; margin:16px 0; box-shadow: 0 1px 3px rgba(0,0,0,0.04); }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    input[type="text"]{ padding:8px 10px; border:1px solid #d1d5db; border-radius:8px; min-width:280px;}
    button{ appearance:none; border:0; background:#111827; color:#fff; padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:600;}
    .muted{ color:#6b7280; font-size:13px;}
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .small{ font-size:12px; }
    .log{ white-space:pre-wrap; font-size:12px; background:#0b1021; color:#c7d2fe; padding:10px; border-radius:8px; }
    .hidden{ display:none; }
  </style>
</head>
<body>
<div class="wrap">
  <h1>3seats — Export (Events as values, Lists with formulas)</h1>
  <div class="card">
    <p class="muted">
      This exports your Excel to Google Sheets while preserving <b>formulas on the Lists sheet</b> and writing <b>Events</b> as values only.
      It uses Google's converter, then copies grids into your Template copy.
    </p>
  </div>

  <div class="card">
    <div class="row">
      <div>
        <label class="small">Output base name</label><br/>
        <input id="fileName" type="text" placeholder="master_output" />
      </div>
      <div>
        <label class="small">&nbsp;</label><br/>
        <button id="btnExport">Export to Google Sheet</button>
      </div>
    </div>
    <div id="status" class="small muted" style="margin-top:10px;">Idle</div>
  </div>

  <div class="card">
    <details>
      <summary class="muted">Advanced (Template & OAuth)</summary>
      <div class="small">
        Template ID: <span class="mono">1ft0PuCB3EneQ8vW9lFv78c1KBC1giUOGTAmLsa8bETE</span><br/>
        OAuth Client ID: <span class="mono">7010858919-jq4n8blq1b73o26pq3h4n0uk46roqfag.apps.googleusercontent.com</span>
      </div>
    </details>
  </div>

  <div id="log" class="log hidden"></div>
</div>

<script async defer src="https://apis.google.com/js/api.js"></script>
<script async defer src="https://accounts.google.com/gsi/client"></script>
<script>
const TEMPLATE_ID = "1ft0PuCB3EneQ8vW9lFv78c1KBC1giUOGTAmLsa8bETE";
const CLIENT_ID   = "7010858919-jq4n8blq1b73o26pq3h4n0uk46roqfag.apps.googleusercontent.com";

const statusEl = document.getElementById('status');
const logEl = document.getElementById('log');
function setStatus(msg){ statusEl.textContent = msg; }
function log(msg){ logEl.classList.remove('hidden'); logEl.textContent += msg + "\n"; console.log("[preserve-lists-formulas]", msg); }

function pickExcel() {
  return new Promise((resolve)=>{
    const inp = document.createElement('input');
    inp.type = 'file';
    inp.accept = ".xlsx,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
    inp.style.position = 'fixed'; inp.style.left = '-9999px';
    document.body.appendChild(inp);
    inp.addEventListener('change', ()=> resolve(inp.files && inp.files[0] ? inp.files[0] : null));
    inp.click();
  });
}

async function ensureGapi() {
  setStatus("Loading Google APIs…");
  await new Promise((resolve,reject)=>{ 
    gapi.load("client", async ()=>{ try{ await gapi.client.init({}); resolve(); }catch(e){ reject(e); } }); 
  });
  await gapi.client.load("https://www.googleapis.com/discovery/v1/apis/drive/v3/rest");
  await gapi.client.load("https://sheets.googleapis.com/$discovery/rest?version=v4");
  log("gapi loaded");
}

async function ensureToken() {
  setStatus("Getting Google token…");
  return await new Promise((resolve,reject)=>{
    const tokenClient = google.accounts.oauth2.initTokenClient({
      client_id: CLIENT_ID,
      scope: "https://www.googleapis.com/auth/drive https://www.googleapis.com/auth/spreadsheets",
      use_fedcm_for_prompt: true,
      callback: ()=>{}
    });
    tokenClient.callback = (r)=> r && r.access_token ? resolve(r.access_token) : reject(new Error(r?.error||"No token"));
    tokenClient.requestAccessToken({prompt:"consent"});
  });
}

async function waitReady(id){
  for (let i=1;i<=10;i++){
    try { const r = await gapi.client.sheets.spreadsheets.get({ spreadsheetId:id, fields:"spreadsheetId" }); if (r?.result?.spreadsheetId) return; } catch(_){}
    await new Promise(r=>setTimeout(r, 250*i));
  }
  throw new Error("Google Sheet not ready.");
}

async function uploadAndConvertXlsx(blob, name){
  const tokenObj = gapi.client.getToken && gapi.client.getToken();
  const accessToken = tokenObj && tokenObj.access_token ? tokenObj.access_token : null;
  if (!accessToken) throw new Error("Missing access token");

  const metadata = {
    name: name + " (Converted)",
    mimeType: "application/vnd.google-apps.spreadsheet"
  };
  const form = new FormData();
  form.append("metadata", new Blob([JSON.stringify(metadata)], { type: "application/json" }));
  form.append("file", blob, (blob && blob.name) ? blob.name : (name + ".xlsx"));

  const res = await fetch("https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id", {
    method: "POST",
    headers: { "Authorization": "Bearer " + accessToken },
    body: form
  });
  if (!res.ok){
    const t = await res.text().catch(()=>"(no body)");
    throw new Error("Upload failed: " + res.status + " " + t);
  }
  const json = await res.json();
  log("Converted file id: " + json.id);
  return json.id;
}

async function ensureSheet(spreadsheetId, title){
  const r = await gapi.client.sheets.spreadsheets.get({
    spreadsheetId, fields: "sheets(properties(sheetId,title))"
  });
  const found = (r.result.sheets||[]).find(s => s.properties.title === title);
  if (found) return found.properties;
  const add = await gapi.client.sheets.spreadsheets.batchUpdate({
    spreadsheetId,
    resource: { requests: [{ addSheet: { properties: { title } } }] }
  });
  return add.result?.replies?.[0]?.addSheet?.properties;
}

async function clearValues(spreadsheetId, sheetTitle){
  await gapi.client.sheets.spreadsheets.values.clear({
    spreadsheetId, range: `${sheetTitle}!A1:ZZZ100000`
  });
}

// Read entire values for a sheet (large range to capture columns > Z)
async function readValues(spreadsheetId, sheetTitle){
  const res = await gapi.client.sheets.spreadsheets.values.get({
    spreadsheetId, range: `${sheetTitle}!A1:ZZZ100000`
  });
  return res.result.values || [];
}

// Write values into dest
async function writeValues(spreadsheetId, sheetTitle, grid){
  if (!grid || !grid.length) return;
  await gapi.client.sheets.spreadsheets.values.update({
    spreadsheetId,
    range: `${sheetTitle}!A1`,
    valueInputOption: "RAW",
    resource: { values: grid, majorDimension: "ROWS" }
  });
}

// Read full cell data (with formulas) for a sheet
async function readCellsWithFormulas(spreadsheetId, sheetTitle){
  const res = await gapi.client.sheets.spreadsheets.get({
    spreadsheetId,
    ranges: [sheetTitle],
    includeGridData: true,
    fields: "sheets(data(rowData(values(userEnteredValue,userEnteredFormat.numberFormat,type))))"
  });
  const sheet = res.result.sheets && res.result.sheets[0];
  const data = sheet && sheet.data && sheet.data[0];
  return (data && data.rowData) ? data.rowData : [];
}

// Write full cell data (formulas preserved when present)
async function writeCellsWithFormulas(spreadsheetId, sheetTitle, rowData){
  // Ensure sheet exists
  const meta = await gapi.client.sheets.spreadsheets.get({ spreadsheetId, fields: "sheets(properties(sheetId,title))" });
  const sheet = (meta.result.sheets||[]).find(s => s.properties.title === sheetTitle);
  if (!sheet) throw new Error(`Destination sheet not found: ${sheetTitle}`);
  const sheetId = sheet.properties.sheetId;

  // Build requests: clear existing cells, then update rows
  const requests = [];

  // Clear to a large grid (keeps sheet present)
  requests.push({
    updateCells: {
      range: { sheetId, startRowIndex: 0, startColumnIndex: 0 },
      fields: "userEnteredValue"
    }
  });

  // Build RowData objects with userEnteredValue (formulaValue, stringValue, numberValue, boolValue)
  // Limit size to avoid huge payloads; typical Lists are modest.
  const sanitizedRows = (rowData || []).map(r => ({
    values: (r.values || []).map(c => {
      const uev = c.userEnteredValue || {};
      const v = {};
      if (typeof uev.formulaValue === "string") v.formulaValue = uev.formulaValue;
      else if (typeof uev.stringValue === "string") v.stringValue = uev.stringValue;
      else if (typeof uev.numberValue === "number") v.numberValue = uev.numberValue;
      else if (typeof uev.boolValue === "boolean") v.boolValue = uev.boolValue;
      else v.stringValue = ""; // empty
      return { userEnteredValue: v };
    })
  }));

  requests.push({
    updateCells: {
      start: { sheetId, rowIndex: 0, columnIndex: 0 },
      rows: sanitizedRows,
      fields: "userEnteredValue"
    }
  });

  await gapi.client.sheets.spreadsheets.batchUpdate({
    spreadsheetId,
    resource: { requests }
  });
}

async function exportNow(){
  try{
    setStatus("Pick the Excel you just downloaded from Generate…");
    const picked = await pickExcel();
    if (!picked){ setStatus("Canceled (no Excel picked)."); return; }

    await ensureGapi();
    const token = await ensureToken();
    gapi.client.setToken({access_token: token});

    const baseName = ((document.getElementById("fileName")?.value || "master_output").trim()||"master_output").replace(/\s+/g,"_");
    setStatus("Copying your template…");
    const copyRes = await gapi.client.drive.files.copy({
      fileId: TEMPLATE_ID, supportsAllDrives: true, fields: "id", resource: { name: baseName + " (Google Sheet)" }
    });
    const destId = copyRes.result.id;
    await waitReady(destId);

    setStatus("Uploading & converting Excel…");
    const convertedId = await uploadAndConvertXlsx(picked, baseName);

    // Detect source sheet titles
    const meta = await gapi.client.sheets.spreadsheets.get({ spreadsheetId: convertedId, fields: "sheets(properties(title))" });
    const titles = (meta.result.sheets || []).map(s => s.properties.title);
    function findTitle(candidates){
      const lc = titles.map(t => t.toLowerCase());
      for (const cand of candidates){
        const i = lc.indexOf(cand.toLowerCase());
        if (i >= 0) return titles[i];
      }
      return null;
    }
    const eventsTitle = findTitle(["Events","Event","Sheet1"]);
    const listsTitle  = findTitle(["Lists","List"]);

    // Ensure destination tabs exist
    await ensureSheet(destId, "Events");
    await ensureSheet(destId, "Lists");

    // Write Events as values only
    if (eventsTitle){
      setStatus("Copying Events (values)…");
      const eventsGrid = await readValues(convertedId, eventsTitle);
      await clearValues(destId, "Events");
      await writeValues(destId, "Events", eventsGrid);
    } else {
      log("Source Events sheet not found.");
    }

    // Write Lists with formulas preserved
    if (listsTitle){
      setStatus("Copying Lists (formulas)…");
      const listsRows = await readCellsWithFormulas(convertedId, listsTitle);
      await writeCellsWithFormulas(destId, "Lists", listsRows);
    } else {
      log("Source Lists sheet not found.");
    }

    setStatus("Opening Google Sheet…");
    window.open(`https://docs.google.com/spreadsheets/d/${destId}/edit`, "_blank");
  }catch(e){
    console.error(e);
    setStatus("Export failed: " + (e?.result?.error?.message || e.message || String(e)));
    alert("Export failed: " + (e?.result?.error?.message || e.message || String(e)));
  }
}

document.getElementById('btnExport').addEventListener('click', function(e){
  e.preventDefault();
  exportNow();
});
</script>

</body>
</html>
