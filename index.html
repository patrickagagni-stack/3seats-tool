<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3seats — Functional + Step 8 Cleanup</title>
  <style>
    :root { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial }
    body { margin:0; background:#fafafa; color:#111 }
    .wrap { max-width: 1100px; margin: 24px auto; padding: 0 16px }
    /* Step card defaults (will be overridden by theme copier JS to match your tool) */
    .ts-card { background:#fff; border:1px solid #e5e7eb; border-radius:12px; padding:18px; margin:16px 0; box-shadow: 0 1px 3px rgba(0,0,0,.04) }
    .ts-row { display:flex; gap:10px; flex-wrap:wrap; align-items:center }
    .ts-input { padding:8px 10px; border:1px solid #d1d5db; border-radius:8px; min-width:280px }
    .ts-btn { appearance:none; border:0; background:#111827; color:#fff; padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:600 }
    .ts-subtle { color:#6b7280; font-size:13px }
    .ts-status { color:#6b7280; font-size:12px; margin-left:10px }
    .ts-step-title { font-weight:700; font-size:16px; margin-bottom:6px }
  </style>
</head>
<body>
<div class="wrap" id="ts-root">
  <!-- Step 8 card gets injected below; we also hide Step 7 button via JS -->
</div>

<!-- Google APIs (safe to include even if already present) -->
<script async defer src="https://apis.google.com/js/api.js"></script>
<script async defer src="https://accounts.google.com/gsi/client"></script>

<script>
(function(){
  // ======== 1) THEME MIMIC: copy styles from your existing steps/buttons to our Step 8 ========
  function mimicTheme(){
    // Try to find a prior "step" container (common patterns)
    const step = document.querySelector('[class*="step"], .card, .section, .panel');
    const btn  = document.querySelector('button, .button, input[type="button"], input[type="submit"]');
    const input= document.querySelector('input[type="text"], input[type="search"], .input');
    const root = document.getElementById('ts-root');

    // Build Step 8 DOM
    const card = document.createElement('div');
    card.className = 'ts-card';
    card.id = 'ts-step8-card';

    const title = document.createElement('div');
    title.className = 'ts-step-title';
    title.textContent = '8) Export to Google Sheets';

    const desc = document.createElement('div');
    desc.className = 'ts-subtle';
    desc.innerHTML = 'Pick the Excel you generated → Google converts it → we copy <b>Events</b> as values and <b>Lists</b> with formulas preserved into your Template copy.';

    const row = document.createElement('div');
    row.className = 'ts-row';

    const name = document.createElement('input');
    name.id = 'ts-export-base';
    name.className = 'ts-input';
    name.placeholder = 'master_output';

    const b = document.createElement('button');
    b.id = 'ts-export-btn';
    b.className = 'ts-btn';
    b.textContent = 'Export to Google Sheet';

    const status = document.createElement('span');
    status.id = 'ts-export-status';
    status.className = 'ts-status';
    status.textContent = 'Idle';

    row.appendChild(name);
    row.appendChild(b);
    row.appendChild(status);
    card.appendChild(title);
    card.appendChild(desc);
    card.appendChild(row);

    // Insert Step 8 at the very end of body, but before any footer
    (root || document.body).appendChild(card);

    // Copy computed styles (non-destructive) if we can find existing theme
    try{
      if (step){
        const stepCS = getComputedStyle(step);
        card.style.background = stepCS.backgroundColor || card.style.background;
        card.style.borderColor= stepCS.borderColor || card.style.borderColor;
        card.style.borderRadius = stepCS.borderRadius || card.style.borderRadius;
        card.style.boxShadow = stepCS.boxShadow || card.style.boxShadow;
      }
      if (btn){
        const btnCS = getComputedStyle(btn);
        b.style.background = btnCS.backgroundColor || b.style.background;
        b.style.color      = btnCS.color || b.style.color;
        b.style.borderRadius = btnCS.borderRadius || b.style.borderRadius;
        b.style.borderColor  = btnCS.borderColor || b.style.borderColor;
        b.style.fontWeight   = btnCS.fontWeight || b.style.fontWeight;
        b.style.padding      = btnCS.padding || b.style.padding;
      }
      if (input){
        const inCS = getComputedStyle(input);
        name.style.borderColor = inCS.borderColor || name.style.borderColor;
        name.style.borderRadius= inCS.borderRadius || name.style.borderRadius;
        name.style.padding     = inCS.padding || name.style.padding;
        name.style.fontSize    = inCS.fontSize || name.style.fontSize;
      }
      const bodyCS = getComputedStyle(document.body);
      document.documentElement.style.setProperty('--ts-font', bodyCS.fontFamily || '');
      document.body.style.fontFamily = bodyCS.fontFamily || document.body.style.fontFamily;
    }catch(e){ console.warn('Theme mimic warning:', e); }
  }

  // ======== 2) HIDE OLD STEP 7 EXPORT BUTTON (non-destructive) ========
  function hideOldStep7(){
    // Look for a heading that starts with "7" and contains "Export" within the same section
    const headings = Array.from(document.querySelectorAll('h1,h2,h3,h4,strong,b,.title,.header'));
    let step7 = null;
    for (const h of headings){
      const t = (h.textContent || '').trim().toLowerCase();
      if (/^7[\).\s]/.test(t) && t.includes('export') && t.includes('google')){
        step7 = h.closest('section, .step, .card, .panel, .box, div');
        if (step7) break;
      }
    }
    // Inside that section, hide any export buttons
    if (step7){
      const candidates = step7.querySelectorAll('button, a, input[type="button"], input[type="submit"]');
      candidates.forEach(el => {
        const txt = (el.textContent || el.value || '').toLowerCase();
        if (txt.includes('export') && txt.includes('google')){
          el.style.display = 'none';
          el.setAttribute('data-ts-hidden', 'step7-export-hidden');
        }
      });
    } else {
      // Fallback: hide any button wired to old export handlers
      const cands = document.querySelectorAll('button, a, input[type="button"], input[type="submit"]');
      cands.forEach(el => {
        const t = (el.textContent || el.value || '').toLowerCase();
        if (t.includes('export') && t.includes('google') && !el.closest('#ts-step8-card')){
          el.style.display = 'none';
          el.setAttribute('data-ts-hidden', 'fallback-export-hidden');
        }
      });
    }
  }

  // ======== 3) EXPORTER LOGIC (Events as values; Lists with formulas) ========
  const TEMPLATE_ID = "1ft0PuCB3EneQ8vW9lFv78c1KBC1giUOGTAmLsa8bETE";
  const CLIENT_ID   = "7010858919-jq4n8blq1b73o26pq3h4n0uk46roqfag.apps.googleusercontent.com";

  const $ = (id)=> document.getElementById(id);
  const setStatus = (m)=> { const s = $('ts-export-status'); if (s) s.textContent = m };

  function pickExcel() {
    return new Promise((resolve)=>{
      const inp = document.createElement('input');
      inp.type = 'file';
      inp.accept = ".xlsx,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
      inp.style.position = 'fixed'; inp.style.left = '-9999px';
      document.body.appendChild(inp);
      inp.addEventListener('change', ()=> resolve(inp.files && inp.files[0] ? inp.files[0] : null));
      inp.click();
    });
  }

  async function ensureGapi() {
    setStatus("Loading Google APIs…");
    await new Promise((resolve,reject)=>{ 
      gapi.load("client", async ()=>{ try{ await gapi.client.init({}); resolve(); }catch(e){ reject(e); } }); 
    });
    await gapi.client.load("https://www.googleapis.com/discovery/v1/apis/drive/v3/rest");
    await gapi.client.load("https://sheets.googleapis.com/$discovery/rest?version=v4");
  }

  async function ensureToken() {
    setStatus("Getting Google token…");
    return await new Promise((resolve,reject)=>{
      const tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: CLIENT_ID,
        scope: "https://www.googleapis.com/auth/drive https://www.googleapis.com/auth/spreadsheets",
        use_fedcm_for_prompt: true,
        callback: ()=>{}
      });
      tokenClient.callback = (r)=> r && r.access_token ? resolve(r.access_token) : reject(new Error(r?.error||"No token"));
      tokenClient.requestAccessToken({prompt:"consent"});
    });
  }

  async function waitReady(id){
    for (let i=1;i<=10;i++){
      try { const r = await gapi.client.sheets.spreadsheets.get({ spreadsheetId:id, fields:"spreadsheetId" }); if (r?.result?.spreadsheetId) return; } catch(_){}
      await new Promise(r=>setTimeout(r, 250*i));
    }
    throw new Error("Google Sheet not ready.");
  }

  async function ensureSheet(spreadsheetId, title){
    const r = await gapi.client.sheets.spreadsheets.get({
      spreadsheetId, fields: "sheets(properties(sheetId,title))"
    });
    const found = (r.result.sheets||[]).find(s => s.properties.title === title);
    if (found) return found.properties;
    const add = await gapi.client.sheets.spreadsheets.batchUpdate({
      spreadsheetId,
      resource: { requests: [{ addSheet: { properties: { title } } }] }
    });
    return add.result?.replies?.[0]?.addSheet?.properties;
  }

  async function clearValues(spreadsheetId, sheetTitle){
    await gapi.client.sheets.spreadsheets.values.clear({
      spreadsheetId, range: `${sheetTitle}!A1:ZZZ100000`
    });
  }

  async function readValues(spreadsheetId, sheetTitle){
    const res = await gapi.client.sheets.spreadsheets.values.get({
      spreadsheetId, range: `${sheetTitle}!A1:ZZZ100000`
    });
    return res.result.values || [];
  }

  async function writeValues(spreadsheetId, sheetTitle, grid){
    if (!grid || !grid.length) return;
    await gapi.client.sheets.spreadsheets.values.update({
      spreadsheetId,
      range: `${sheetTitle}!A1`,
      valueInputOption: "RAW",
      resource: { values: grid, majorDimension: "ROWS" }
    });
  }

  async function readCellsWithFormulas(spreadsheetId, sheetTitle){
    const res = await gapi.client.sheets.spreadsheets.get({
      spreadsheetId,
      ranges: [`${sheetTitle}!A1:ZZZ100000`],
      includeGridData: true,
      fields: "sheets(data(rowData(values(userEnteredValue))))"
    });
    const sheet = res.result.sheets && res.result.sheets[0];
    const data = sheet && sheet.data && sheet.data[0];
    return (data && data.rowData) ? data.rowData : [];
  }

  async function writeCellsWithFormulas(spreadsheetId, sheetTitle, rowData){
    const meta = await gapi.client.sheets.spreadsheets.get({
      spreadsheetId,
      fields: "sheets(properties(sheetId,title))"
    });
    const sheet = (meta.result.sheets||[]).find(s => s.properties.title === sheetTitle);
    if (!sheet) throw new Error(`Destination sheet not found: ${sheetTitle}`);
    const sheetId = sheet.properties.sheetId;

    const sanitizedRows = (rowData || []).map(r => ({
      values: (r.values || []).map(c => {
        const uev = (c && c.userEnteredValue) ? c.userEnteredValue : {};
        const v = {};
        if (typeof uev.formulaValue === "string")      v.formulaValue = uev.formulaValue;
        else if (typeof uev.stringValue  === "string") v.stringValue  = uev.stringValue;
        else if (typeof uev.numberValue  === "number") v.numberValue  = uev.numberValue;
        else if (typeof uev.boolValue    === "boolean")v.boolValue    = uev.boolValue;
        else                                           v.stringValue  = "";
        return { userEnteredValue: v };
      })
    }));

    await gapi.client.sheets.spreadsheets.values.clear({
      spreadsheetId, range: `${sheetTitle}!A1:ZZZ100000`
    });

    await gapi.client.sheets.spreadsheets.batchUpdate({
      spreadsheetId,
      resource: {
        requests: [{
          updateCells: {
            range: { sheetId: sheetId, startRowIndex: 0, startColumnIndex: 0 },
            rows: sanitizedRows,
            fields: "userEnteredValue"
          }
        }]
      }
    });
  }

  async function uploadAndConvertXlsx(blob, name){
    const tokenObj = gapi.client.getToken && gapi.client.getToken();
    const accessToken = tokenObj && tokenObj.access_token ? tokenObj.access_token : null;
    if (!accessToken) throw new Error("Missing access token");

    const metadata = { name: name + " (Converted)", mimeType: "application/vnd.google-apps.spreadsheet" };
    const form = new FormData();
    form.append("metadata", new Blob([JSON.stringify(metadata)], { type: "application/json" }));
    form.append("file", blob, (blob && blob.name) ? blob.name : (name + ".xlsx"));

    const res = await fetch("https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id", {
      method: "POST", headers: { "Authorization": "Bearer " + accessToken }, body: form
    });
    if (!res.ok){ const t = await res.text().catch(()=>"(no body)"); throw new Error("Upload failed: " + res.status + " " + t); }
    const json = await res.json();
    return json.id;
  }

  function findTitle(titles, candidates){
    const lc = titles.map(t => t.toLowerCase());
    for (const cand of candidates){
      const i = lc.indexOf(cand.toLowerCase());
      if (i >= 0) return titles[i];
    }
    return null;
  }

  async function exportNow(){
    try{
      setStatus("Pick the Excel you just downloaded from Generate…");
      const picked = await pickExcel();
      if (!picked){ setStatus("Canceled (no Excel picked)."); return; }

      await ensureGapi();
      const token = await ensureToken();
      gapi.client.setToken({access_token: token});

      const baseName = ((document.getElementById('ts-export-base')?.value || document.getElementById('fileName')?.value || 'master_output').trim()||'master_output').replace(/\s+/g,'_');

      setStatus("Copying your template…");
      const copyRes = await gapi.client.drive.files.copy({
        fileId: TEMPLATE_ID, supportsAllDrives: true, fields: "id", resource: { name: baseName + " (Google Sheet)" }
      });
      const destId = copyRes.result.id;
      await waitReady(destId);

      setStatus("Uploading & converting Excel…");
      const convertedId = await uploadAndConvertXlsx(picked, baseName);

      setStatus("Analyzing converted sheets…");
      const meta = await gapi.client.sheets.spreadsheets.get({ spreadsheetId: convertedId, fields: "sheets(properties(title))" });
      const titles = (meta.result.sheets || []).map(s => s.properties.title);
      const eventsTitle = findTitle(titles, ["Events","Event","Sheet1"]);
      const listsTitle  = findTitle(titles, ["Lists","List"]);

      await ensureSheet(destId, "Events");
      await ensureSheet(destId, "Lists");

      if (eventsTitle){
        setStatus("Copying Events (values)…");
        const eventsGrid = await readValues(convertedId, eventsTitle);
        await clearValues(destId, "Events");
        await writeValues(destId, "Events", eventsGrid);
      }

      if (listsTitle){
        setStatus("Copying Lists (formulas)…");
        const listsRows = await readCellsWithFormulas(convertedId, listsTitle);
        await writeCellsWithFormulas(destId, "Lists", listsRows);
      }

      setStatus("Opening Google Sheet…");
      window.open(`https://docs.google.com/spreadsheets/d/${destId}/edit`, "_blank");
      setStatus("Done");
    }catch(e){
      console.error(e);
      const msg = e?.result?.error?.message || e.message || String(e);
      const dbg = e?.result ? JSON.stringify(e.result, null, 2) : "";
      setStatus("Export failed: " + msg);
      alert("Export failed: " + msg + (dbg ? "\n\n" + dbg : ""));
    }
  }

  document.addEventListener('DOMContentLoaded', function(){
    mimicTheme();
    hideOldStep7();
    const btn = document.getElementById('ts-export-btn');
    if (btn) btn.addEventListener('click', function(e){ e.preventDefault(); exportNow(); });
  });
})();
</script>
</body>
</html>
