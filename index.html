<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3seats Tool — Direct to Google Sheets</title>
  <style>
    :root { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"; color-scheme: light; }
    body { margin: 0; padding: 24px; background: #fafafa; color: #111; }
    .wrap { max-width: 960px; margin: 0 auto; }
    h1 { margin: 0 0 12px 0; font-size: 20px; }
    .card { background: #fff; border: 1px solid #e5e7eb; border-radius: 12px; padding: 16px 18px; margin: 12px 0; box-shadow: 0 1px 2px rgba(0,0,0,0.04); }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items:center; }
    label { font-size: 12px; color: #374151; }
    input[type="text"] { padding: 8px 10px; border: 1px solid #d1d5db; border-radius: 8px; min-width: 260px; }
    button { appearance: none; border: 0; background: #111827; color: #fff; padding: 10px 14px; border-radius: 10px; cursor: pointer; font-weight: 600; }
    button.secondary { background: #374151; }
    .muted { color: #6b7280; font-size: 13px; }
    .ok { color: #065f46; }
    .warn { color: #92400e; }
    .divider { height: 1px; background: #eee; margin: 12px 0; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .small { font-size: 12px; color: #6b7280; }
    .hidden { display:none; }
  </style>
</head>
<body>
<div class="wrap">

  <h1>3seats Tool — Direct to Google Sheets</h1>
  <div class="card">
    <p class="muted">This version writes straight to Google Sheets (no Excel step required). If your existing tool already builds <code class="mono">window.customer</code> with <code>headers</code> and <code>rows</code>, the exporter will use that exact data. If not, you can still click <b>Export to Google Sheet</b> and choose the Excel you just downloaded—it will be converted and copied into your template.</p>
  </div>

  <div class="card">
    <div class="row">
      <div>
        <label for="fileName">Output name (base):</label><br/>
        <input id="fileName" type="text" placeholder="master_output" />
      </div>
      <div>
        <label>&nbsp;</label><br/>
        <button id="btnExport">Export to Google Sheet</button>
      </div>
    </div>
    <div class="divider"></div>
    <div id="status" class="small muted"></div>
  </div>

  <div class="card">
    <details>
      <summary class="muted">Troubleshooting / How it works</summary>
      <ul class="small">
        <li><b>Preferred path:</b> Uses <code>window.customer.headers</code> + <code>window.customer.rows</code> (what your “Generate” step should build) so the <b>Events</b> sheet includes <b>all columns (beyond Z)</b> exactly.</li>
        <li><b>Fallback path:</b> If in‑memory data isn’t available, it will prompt you to <b>pick the Excel</b> you just downloaded, convert it to Google Sheets, and copy its tabs into your <b>Template copy</b>.</li>
        <li>Template is copied from: <code class="mono">1ft0PuCB3EneQ8vW9lFv78c1KBC1giUOGTAmLsa8bETE</code> (keeps your email tooling).</li>
        <li>OAuth Client ID in use: <code class="mono">7010858919-jq4n8blq1b73o26pq3h4n0uk46roqfag.apps.googleusercontent.com</code></li>
      </ul>
    </details>
  </div>

</div>

<!-- Google platform scripts -->
<script async defer src="https://apis.google.com/js/api.js"></script>
<script async defer src="https://accounts.google.com/gsi/client"></script>

<script>
const TEMPLATE_ID = "1ft0PuCB3EneQ8vW9lFv78c1KBC1giUOGTAmLsa8bETE";
const CLIENT_ID   = "7010858919-jq4n8blq1b73o26pq3h4n0uk46roqfag.apps.googleusercontent.com";

function setStatus(msg, cls="muted"){ 
  const el = document.getElementById("status"); 
  el.className = "small " + cls; 
  el.textContent = msg; 
}

function pickExcel() {
  return new Promise((resolve)=>{
    const inp = document.createElement('input');
    inp.type = 'file';
    inp.accept = ".xlsx,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
    inp.style.position = 'fixed'; inp.style.left = '-9999px';
    document.body.appendChild(inp);
    inp.addEventListener('change', ()=> resolve(inp.files && inp.files[0] ? inp.files[0] : null));
    inp.click();
  });
}

async function ensureGapi() {
  setStatus("Loading Google APIs…");
  await new Promise((resolve,reject)=>{ 
    gapi.load("client", async ()=>{ try{ await gapi.client.init({}); resolve(); }catch(e){ reject(e); } }); 
  });
  await gapi.client.load("https://www.googleapis.com/discovery/v1/apis/drive/v3/rest");
  await gapi.client.load("https://sheets.googleapis.com/$discovery/rest?version=v4");
}

async function ensureToken() {
  return await new Promise((resolve,reject)=>{
    const tokenClient = google.accounts.oauth2.initTokenClient({
      client_id: CLIENT_ID,
      scope: "https://www.googleapis.com/auth/drive https://www.googleapis.com/auth/spreadsheets",
      use_fedcm_for_prompt: true,
      callback: ()=>{}
    });
    tokenClient.callback = (r)=> r && r.access_token ? resolve(r.access_token) : reject(new Error(r?.error||"No token"));
    tokenClient.requestAccessToken({prompt:"consent"});
  });
}

async function waitReady(id){
  for (let i=1;i<=10;i++){
    try { const r = await gapi.client.sheets.spreadsheets.get({ spreadsheetId:id, fields:"spreadsheetId" }); if (r?.result?.spreadsheetId) return; } catch(_){}
    await new Promise(r=>setTimeout(r, 300*i));
  }
  throw new Error("Google Sheet not ready.");
}

async function uploadAndConvertXlsx(blob, name){
  const metadata = new Blob([JSON.stringify({ name: name + " (Converted)", mimeType: "application/vnd.google-apps.spreadsheet" })], { type: "application/json" });
  const boundary = "-------314159265358979323846";
  const delimiter = "
--" + boundary + "
";
  const closeDelim = "
--" + boundary + "--";
  const body = new Blob([
    delimiter, 'Content-Type: application/json; charset=UTF-8

', metadata,
    delimiter, 'Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet

', blob, closeDelim
  ], { type: "multipart/related; boundary=" + boundary });

  const res = await gapi.client.request({
    path: "/upload/drive/v3/files?uploadType=multipart&fields=id",
    method: "POST",
    body,
    headers: { "Content-Type": "multipart/related; boundary=" + boundary }
  });
  return res.result.id;
}

// ---- Direct write path (preferred) ----
function computeDirectGrids(){
  // Requires window.customer = { headers: [...], rows: [ {header:value,...}, ... ] }
  if (!window.customer || !Array.isArray(window.customer.rows) || !window.customer.rows.length) return null;

  // Try to infer mapping UI (if present). If not, assume headers are already desired outputs.
  const mappingRows = Array.from(document.querySelectorAll('#mappingRows .mapping-row'));
  let headersOut;
  if (mappingRows.length){
    const labelToKey = (el)=>{
      if (!el) return "";
      const t = (el.textContent || "").replace("required","").trim();
      return t;
    };
    headersOut = mappingRows.map(r => labelToKey(r.children?.[0])).filter(Boolean);
    // append extras if an "append" checkbox exists
    const used = new Set();
    mappingRows.forEach(row => {
      const sel = row.children?.[1];
      if (sel && sel.value) used.add(sel.value);
    });
    const append = document.getElementById('appendExtras')?.checked;
    const extras = append ? (window.customer.headers||[]).filter(h => h && !used.has(h)) : [];
    headersOut = [...headersOut, ...extras];
  } else {
    // No mapping UI detected: use uploaded headers directly
    headersOut = Array.isArray(window.customer.headers) ? window.customer.headers.slice() : Object.keys(window.customer.rows[0]||{});
  }

  // Make the grid
  const eventsGrid = [ headersOut ];
  for (const row of window.customer.rows){
    eventsGrid.push(headersOut.map(h => (row[h] ?? "")));
  }

  // Lists columns (I-L): expect arrays if present; else empty
  const unmatchedRooms   = Array.isArray(window.unmatched_rooms)   ? window.unmatched_rooms   : [];
  const unmatchedOwners  = Array.isArray(window.unmatched_owners)  ? window.unmatched_owners  : [];
  const unmatchedStatus  = Array.isArray(window.unmatched_status)  ? window.unmatched_status  : [];
  const appendedHeaders  = Array.isArray(window.appended_headers)  ? window.appended_headers  : [];

  const maxListLen = Math.max(unmatchedRooms.length, unmatchedOwners.length, unmatchedStatus.length, appendedHeaders.length);
  const listsGrid = [];
  listsGrid.push(["unmatched_rooms", "unmatched_owners", "unmatched_status", "appended_headers"]);
  for (let i=0; i<maxListLen; i++){
    listsGrid.push([
      unmatchedRooms[i]  ?? "",
      unmatchedOwners[i] ?? "",
      unmatchedStatus[i] ?? "",
      appendedHeaders[i] ?? ""
    ]);
  }
  return { eventsGrid, listsGrid };
}

async function putValues(spreadsheetId, sheetTitle, grid){
  if (!grid || !grid.length) return;
  // Clear a large range to avoid leftovers, but preserve formatting where possible
  await gapi.client.sheets.spreadsheets.values.clear({
    spreadsheetId,
    range: `${sheetTitle}!A1:ZZ100000`
  });
  await gapi.client.sheets.spreadsheets.values.update({
    spreadsheetId,
    range: `${sheetTitle}!A1`,
    valueInputOption: "RAW",
    resource: { values: grid, majorDimension: "ROWS" }
  });
}

async function ensureSheet(spreadsheetId, title){
  const r = await gapi.client.sheets.spreadsheets.get({
    spreadsheetId, fields: "sheets(properties(sheetId,title))"
  });
  const found = (r.result.sheets||[]).find(s => s.properties.title === title);
  if (found) return found.properties;
  const add = await gapi.client.sheets.spreadsheets.batchUpdate({
    spreadsheetId,
    resource: { requests: [{ addSheet: { properties: { title } } }] }
  });
  return add.result?.replies?.[0]?.addSheet?.properties;
}

async function exportToGoogle(){
  try{
    setStatus("Starting export…");

    await ensureGapi();
    const token = await ensureToken();
    gapi.client.setToken({access_token: token});

    // Copy the template first
    const baseName = ((document.getElementById("fileName")?.value || "master_output").trim()||"master_output").replace(/\s+/g,"_");
    const gsName = baseName + " (Google Sheet)";
    setStatus("Copying template…");
    const copyRes = await gapi.client.drive.files.copy({
      fileId: TEMPLATE_ID, supportsAllDrives: true, fields: "id", resource: { name: gsName }
    });
    const spreadsheetId = copyRes.result.id;
    await waitReady(spreadsheetId);

    // Try direct write path first
    const grids = computeDirectGrids();
    if (grids){
      setStatus("Writing data directly to Google Sheets…");
      await ensureSheet(spreadsheetId, "Events");
      await ensureSheet(spreadsheetId, "Lists");
      await putValues(spreadsheetId, "Events", grids.eventsGrid);
      await putValues(spreadsheetId, "Lists",  grids.listsGrid);
      setStatus("Opening Google Sheet…", "ok");
      window.open(`https://docs.google.com/spreadsheets/d/${spreadsheetId}/edit`, "_blank");
      return;
    }

    // Otherwise, pick an Excel and convert/copy it
    setStatus("No in-memory data found. Please pick the Excel you downloaded from Generate…");
    const picked = await pickExcel();
    if (!picked){ setStatus("Export canceled (no Excel selected).", "warn"); return; }

    setStatus("Uploading and converting Excel…");
    const convertedId = await uploadAndConvertXlsx(picked, baseName);

    setStatus("Copying sheets into your template copy…");
    // List sheets in converted file
    const getSheets = async (id) => {
      const res = await gapi.client.sheets.spreadsheets.get({ spreadsheetId: id, fields:"sheets(properties(sheetId,title,index))" });
      return (res.result.sheets||[]).map(s=>s.properties);
    };
    const srcSheets = await getSheets(convertedId);
    // Copy each over
    for (const s of srcSheets){
      await gapi.client.sheets.spreadsheets.sheets.copyTo({
        spreadsheetId: convertedId, sheetId: s.sheetId,
        resource: { destinationSpreadsheetId: spreadsheetId }
      });
    }
    // Remove placeholders (keep only inserted ones)
    const dstSheets = await getSheets(spreadsheetId);
    const insertedTitles = new Set(srcSheets.map(s=>s.title));
    const toDelete = dstSheets.filter(p => !insertedTitles.has(p.title));
    if (toDelete.length){
      await gapi.client.sheets.spreadsheets.batchUpdate({
        spreadsheetId,
        resource: { requests: toDelete.map(p => ({ deleteSheet: { sheetId: p.sheetId } })) }
      });
    }

    setStatus("Opening Google Sheet…", "ok");
    window.open(`https://docs.google.com/spreadsheets/d/${spreadsheetId}/edit`, "_blank");
  }catch(e){
    console.error(e);
    setStatus("Export failed: " + (e?.result?.error?.message || e.message || String(e)), "warn");
    alert("Export failed: " + (e?.result?.error?.message || e.message || String(e)));
  }
}

document.getElementById("btnExport").addEventListener("click", function(e){
  e.preventDefault();
  exportToGoogle();
});

// Expose for any existing onclick wires in your template
window.exportToSheets = exportToGoogle;
</script>

</body>
</html>
